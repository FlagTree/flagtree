#include "xpu/kernel/xtdk.h"
#include "xpu/kernel/xtdk_math.h"
#include "xpu/kernel/xtdk_simd.h"
#include "xpu/kernel/xtdk_atomic_sm_xpu3.h"
#include "xpu/kernel/xtdk_io.h"
#include "xpu/kernel/xtdk_fp16.h"

#include <limits>

#define inline __attribute__((always_inline))
#define PI 3.14159265358979323846f
// Value of ln2 and ln10
#define LN2 0.69314718055994530942f
#define LN10 2.30258509299404568402f

#define HUGE_VALF 1e10000f
#define INFINITY HUGE_VALF

#ifdef __GNUC__
#define predict_true(x) __builtin_expect(!!(x), 1)
#define predict_false(x) __builtin_expect(x, 0)
#else
#define predict_true(x) (x)
#define predict_false(x) (x)
#endif

// TODO[dyq]: replace asm by builtin for scheduling
namespace xpu {

#ifdef __arch_xpu2__
typedef struct {
    unsigned short val;
} float16;
#endif

#ifdef __arch_xpu3__
typedef _Float16 float16;
#endif

#define __CHECK_CLUSTER_ID (0)


__device__ inline void printTest(int customIdx) {
    printf("[printTest_%d] cluster_id[%d] cid[%d/%d]\n", customIdx, cluster_id(), core_num(), core_id());
}

__device__ inline void printBool(bool b, int customIdx) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID && coreId == 0) {
        if (b) {
            printf("[printBool_%d] cluster_id = %d, core_id = %d, local_x[0] = true \n", customIdx, clusterId, coreId);
        } else {
            printf("[printBool_%d] cluster_id = %d, core_id = %d, local_x[0] = false \n", customIdx, clusterId, coreId);
        }
    }
}

__device__ inline void printFloat(float a, int customIdx) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID && coreId == 0) {
        printf("[printFloat_%d] cluster_id = %d, core_id = %d, local_x[0] = %f \n", customIdx, clusterId, coreId, a);
    }
}

__device__ inline void printFloat_spec(float a, int clu_id, int cid, int customIdx) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID && coreId == cid) {
        printf("[printFloat_%d] cluster_id = %d, core_id = %d, local_x[0] = %f \n", customIdx, clusterId, coreId, a);
    }
}

__device__ inline void printFloat_all(float a, int customIdx) {
    int clusterId = cluster_id();
    int coreId = core_id();
    printf("[printFloat_%d] cluster_id = %d, core_id = %d, local_x[0] = %f \n", customIdx, clusterId, coreId, a);
}

__device__ inline void printInt(int a, int customIdx) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID && coreId == 0) {
        printf("[printInt_%d] cluster_id = %d, core_id = %d, local_x[0] = %d \n", customIdx, clusterId, coreId, a);
    }
}

__device__ inline void printInt64(int64_t a, int customIdx) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID && coreId == 0) {
        printf("[printInt64_%d] cluster_id = %d, core_id = %d, local_x[0] = %ld \n", customIdx, clusterId, coreId, a);
    }
}

__device__ inline void printMMaOp(int a, int b, int c, int isAcc) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printMMAOp] cluster_id = %d, core_id = %d, mma %d %d %d isAcc %d\n", clusterId, coreId, a, b, c, isAcc);
    }
}

__device__ inline void printDsOp(int a, int b) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printDsOp l1d] cluster_id = %d, core_id = %d, ds %d %d\n", clusterId, coreId, a, b);
    }
}

 __device__ inline void printGatherOp(int a, int b) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printGatherOp gather] cluster_id = %d, core_id = %d, gather line and mask: %d %d\n", clusterId, coreId, a, b);
    }
}

 __device__ inline void printScatterOp(int a, int b) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printScatterOp scatter] cluster_id = %d, core_id = %d, scatter line and mask: %d %d\n", clusterId, coreId, a, b);
    }
}

__device__ inline void printDmaOp(int64_t a, int b, int c, int is_cached) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printDmaOp] cluster_id = %d, core_id = %d, dma is_cached? %d src 0x%lx unisram 0x%x len %d\n", clusterId, coreId, is_cached, a, b, c);
    }
}

__device__ inline void printDmaolOp(int64_t a) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printDmaolOp] cluster_id = %d, core_id = %d, dmao %ld\n", clusterId, coreId, a);
    }
}

__device__ inline void printDmaoOp(int a) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printDMAOop] cluster_id = %d, core_id = %d, dmao %d\n", clusterId, coreId, a);
    }
}

__device__ inline void printDsCachedL1d(int isCached, int offset, int bufferAddr) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printDsIscached] cluster_id = %d, core_id = %d, ds cached? %d, unisram %d l1d %d\n",
            clusterId, coreId, isCached, offset, bufferAddr);
    }
}

__device__ inline void printDsCachedL1w(int isCached, int offset, int bufferAddr) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printDsIscached] cluster_id = %d, core_id = %d, ds cached? %d, unisram %d l1w %d\n",
            clusterId, coreId, isCached, offset, bufferAddr);
    }
}

__device__ inline void printGetCacheOp(int is_cached, int offset, int bufferIdx, int addr) {
    int clusterId = cluster_id();
    int coreId = core_id();
    if (clusterId == __CHECK_CLUSTER_ID) {
        printf("[printGetCacheOp] cluster_id = %d, core_id = %d, ds cached? %d, offset %d bufferIdx %d, l1dw %d\n",
            clusterId, coreId, is_cached, offset, bufferIdx, addr);
    }
}

__device__ void inline fp16tofp32(const float16* x, float* y, int len) {
    int start = (len - 1) / 32 * 32;
    x = x + start;
    y = y + start;
    for (int i = start; i >= 0; i -= 32) {
        float16x32_t X = vload_lm_float16x32(x);
        float32x16_t X_l = vfp162float_l(X);
        float32x16_t X_h = vfp162float_h(X);
        vstore_lm_float32x16_mz(y + 16, X_h, 0);
        vstore_lm_float32x16_mz(y, X_l, 0);
        x -= 32;
        y -= 32;
    }
    mfence_lm();
}


__device__ void inline fp32tofp16(const float* x, float16* y, int len) {
    for (int i = 0; i < len; i += 32) {
        float32x16_t Y_l = __builtin_xpu2_vload_mask16_mr1(x, 0);
        float32x16_t Y_h = __builtin_xpu2_vload_mask16_mr1(x + 16, 0);
        float16x32_t Y;
        Y = vfloat2fp16_l(Y_l, Y);
        Y = vfloat2fp16_h(Y_h, Y);
        vstore_lm_float16x32_mz(y, Y, 0);
        x += 32;
        y += 32;
    }
    mfence_lm();
}

static __device__ inline void taylor_sin(float *C1, float *C3, float *C5, float *C7, float *C9) {
    *C1 = 1;
    *C3 = -0.16666666666666666;
    *C5 = 0.008333333333333333;
    *C7 = -0.0001984126984126984;
    *C9 = 2.7557319223985893e-06;
}

static __device__ inline void taylor_arcsin(float *C1, float *C3, float *C5, float *C7, float *C9) {
    *C1 = 1;
    *C3 = 1.0f / 6.0f;
    *C5 = 3.0f / 40.0f;
    *C7 = 5.0f / 112.0f;
    *C9 = 35.0f / 1152.0f;
}

// standardized input into [-PI, PI] interval
static __device__ inline void translation_sin(float *input) {
    float tmp;
    tmp = *input;
    int factor = int(*input / PI);
    tmp = tmp - factor * PI;
    if (factor % 2 != 0){
        tmp = -tmp;
    }
    *input = tmp;
}

__device__ inline float nearbyint(float input) {
    return rint(input);
}

__device__ inline float rint(float __x) { return __builtin_rintf(__x); }

__device__ inline float sinf(float input) {
    float C1, C3, C5, C7, C9;
    taylor_sin(&C1, &C3, &C5, &C7, &C9);

    translation_sin(&input);

    // make the input exist in the [- PI/2, PI/2] interval,
    // taylor expansion is more effective for this part
    if (input > (PI / 2)) {
        input = PI - input;
    } else if (input < (-PI / 2)) {
        input = -PI - input;
    }

    // taylor expansion process
    float tmp0 = input * input;
    float tmp1 = tmp0 * input;
    float tmp2 = tmp1 * tmp0;
    float tmp3 = tmp2 * tmp0;
    float tmp4 = tmp3 * tmp0;
    float result = C1 * input + C3 * tmp1 + C5 * tmp2 + C7 * tmp3 + C9 * tmp4;

    return result;
}


// 把不在 [-pi, pi]的数map到[-pi, pi]区间内，len通常=32
static __device__ inline void translation_sin(float* input, int len) {
    for (int k = 0; k < len; k++) {
        float tmp;
        tmp = *(input + k);
        int factor = int(*(input + k) / PI);
        tmp = tmp - factor * PI;                         //取余数
        if (factor % 2 != 0) {
            tmp = -tmp;
        }
        *(input + k) = tmp;
    }
}

__device__ inline float32x16_t vsinf(float32x16_t input) {
    float C1, C3, C5, C7, C9;
    taylor_sin(&C9, &C7, &C5, &C3, &C1);

    // 把转成float32的数在LM进行处理，使得处于区间[-pi, pi]
    __simd__ float tmp_lm[16];
    vstore_lm_float32x16(tmp_lm, input);
    mfence_lm();
    translation_sin(tmp_lm, 16);
    mfence_lm();

    float32x16_t tmp1, tmp2, v0l;
    v0l = vload_lm_float32x16(tmp_lm);

    // 如果x>pi/2, x=pi-x
    // 如果x< -pi/2, x= -pi -x
    // 使得所有数都在[-pi/2, pi/2],泰勒展开对这部分比较有效
    int mask = svle_float32x16(PI / 2, v0l);
    tmp1 = svsub_float32x16_mz(PI, v0l, mask);
    tmp2 = svadd_float32x16_mz(0, v0l, ~mask);
    v0l = vvadd_float32x16(tmp1, tmp2);
    tmp1 = svmul_float32x16(-1, v0l);
    mask = svlt_float32x16(PI / 2, tmp1);
    tmp1 = svsub_float32x16_mz(-PI, v0l, mask);
    tmp2 = svadd_float32x16_mz(0, v0l, ~mask);
    v0l = vvadd_float32x16(tmp1, tmp2);

    //泰勒展开过程
    tmp1 = vvmul_float32x16(v0l, v0l);      // tmp0 = a*a
    tmp2 = svmul_float32x16(C1, tmp1);      // C1*tmp0
    tmp2 = svadd_float32x16(C3, tmp2);      // C3 + C1*tmp0
    tmp2 = vvmul_float32x16(tmp2, tmp1);    // C3*tmp0 + C1*tmp0*tmp0
    tmp2 = svadd_float32x16(C5, tmp2);      // C5 + C3*tmp0 + C1*tmp0*tmp0
    tmp2 = vvmul_float32x16(tmp2, tmp1);    // C5*tmp0 + C3*tmp0*tmp0 + C1*tmp0*tmp0*tmp0
    tmp2 = svadd_float32x16(C7, tmp2);      // C7 + C5*tmp0 + C3*tmp0*tmp0 + C1*tmp0*tmp0*tmp0
    tmp2 = vvmul_float32x16(tmp2, tmp1);    // C7*tmp0 + C5*tmp0 + C3*tmp0*tmp0 + C1*tmp0*tmp0*tmp0
    tmp2 = svadd_float32x16(C9, tmp2);
    v0l = vvmul_float32x16(tmp2, v0l);

    return v0l;
}

__device__ inline float16x32_t vsinf(float16x32_t input) {
    float32x16_t vl_input = vfp162float_l(input);
    float32x16_t vh_input = vfp162float_h(input);
    float32x16_t vl_sin = vsinf(vl_input);
    float32x16_t vh_sin = vsinf(vh_input);
    float16x32_t v_sin = vfloat2fp16_lh(vl_sin, vh_sin);
    return v_sin;
}

// 先把cos函数平移成sin函数，再把不在 [-pi, pi]的数map到[-pi, pi]区间内，len通常=32
static __device__ inline void translation_cos(float* input, int len) {
    for (int k = 0; k < len; k++) {
        float tmp = *(input + k) + PI / 2;                 //平移
        int factor = int(tmp / PI);
        tmp = tmp - factor * PI;
        if (factor % 2 != 0) {
            tmp = -tmp;
        }
        *(input + k) = tmp;
    }
}

__device__ inline float32x16_t vcosf(float32x16_t input) {
    float C1, C3, C5, C7, C9;
    taylor_sin(&C9, &C7, &C5, &C3, &C1);

    // 把转成float32的数在LM进行处理，使得处于区间[-pi, pi]
    __simd__ float tmp_lm[16];
    vstore_lm_float32x16(tmp_lm, input);
    mfence_lm();
    translation_cos(tmp_lm, 16);
    mfence_lm();

    float32x16_t tmp1, tmp2, v0l;
    v0l = vload_lm_float32x16(tmp_lm);

    // 如果x>pi/2, x=pi-x
    // 如果x< -pi/2, x= -pi -x
    // 使得所有数都在[-pi/2, pi/2],泰勒展开对这部分比较有效
    int mask = svle_float32x16(PI / 2, v0l);
    tmp1 = svsub_float32x16_mz(PI, v0l, mask);
    tmp2 = svadd_float32x16_mz(0, v0l, ~mask);
    v0l = vvadd_float32x16(tmp1, tmp2);
    tmp1 = svmul_float32x16(-1, v0l);
    mask = svlt_float32x16(PI / 2, tmp1);
    tmp1 = svsub_float32x16_mz(-PI, v0l, mask);
    tmp2 = svadd_float32x16_mz(0, v0l, ~mask);
    v0l = vvadd_float32x16(tmp1, tmp2);

    //泰勒展开过程
    tmp1 = vvmul_float32x16(v0l, v0l);
    tmp2 = svmul_float32x16(C1, tmp1);
    tmp2 = svadd_float32x16(C3, tmp2);
    tmp2 = vvmul_float32x16(tmp2, tmp1);
    tmp2 = svadd_float32x16(C5, tmp2);
    tmp2 = vvmul_float32x16(tmp2, tmp1);
    tmp2 = svadd_float32x16(C7, tmp2);
    tmp2 = vvmul_float32x16(tmp2, tmp1);
    tmp2 = svadd_float32x16(C9, tmp2);
    v0l = vvmul_float32x16(tmp2, v0l);

    return v0l;
}

__device__ inline float16x32_t vcosf(float16x32_t input) {
    float32x16_t vl_input = vfp162float_l(input);
    float32x16_t vh_input = vfp162float_h(input);
    float32x16_t vl_cos = vcosf(vl_input);
    float32x16_t vh_cos = vcosf(vh_input);
    float16x32_t v_cos = vfloat2fp16_lh(vl_cos, vh_cos);
    return v_cos;
}

// Translate cos into sin, convert to [-PI, PI]
static __device__ inline void translation_cos(float* input) {
    float tmp;
    tmp = *input + PI / 2;
    int factor = int(tmp / PI);
    tmp = tmp - factor * PI;
    if (factor % 2 != 0){
        tmp = -tmp;
    }
    *input = tmp;
}

extern __device__ inline float cosf(float input) {
    float C1, C3, C5, C7, C9;
    taylor_sin(&C1, &C3, &C5, &C7, &C9);

    translation_cos(&input);

    // make the input exist in the [-PI/2, PI/2]
    if (input > (PI / 2)) {
        input = PI - input;
    } else if (input < (-PI / 2)) {
        input = -PI - input;
    }

    // taylor expansion process
    float tmp0 = input * input;
    float tmp1 = tmp0 * input;
    float tmp2 = tmp1 * tmp0;
    float tmp3 = tmp2 * tmp0;
    float tmp4 = tmp3 * tmp0;
    float result = C1 * input + C3 * tmp1 + C5 * tmp2 + C7 * tmp3 + C9 * tmp4;

    return result;
}



static __device__ inline void translation_tan(float* input) {
    float tmp = *input;
    int factor = int(tmp / (PI/2));
    tmp = tmp - factor * (PI/2);
    if (factor % 2 != 0) {
         if (factor > 0) {
             tmp = tmp - (PI/2);
         } else if (factor < 0) {
             tmp = tmp + (PI/2);
         }
    }
    *input = tmp;
}

__device__ inline float tanf(float input) {
    float C1, C3, C5, C7, C9;
    taylor_sin(&C1, &C3, &C5, &C7, &C9);

    translation_tan(&input);

    // sin
    float tmp0 = input * input;
    float tmp1 = tmp0 * input;
    float tmp2 = tmp1 * tmp0;
    float tmp3 = tmp2 * tmp0;
    float tmp4 = tmp3 * tmp0;
    float result_sin = C1 * input + C3 * tmp1 + C5 * tmp2 + C7 * tmp3 + C9 * tmp4;

    // cos
    input = input + PI/2;
    if (input > (PI/2)) {
        input = PI - input;  // sin (pi-x) = sin x
    }

    tmp0 = input * input;
    tmp1 = tmp0 * input;
    tmp2 = tmp1 * tmp0;
    tmp3 = tmp2 * tmp0;
    tmp4 = tmp3 * tmp0;
    float result_cos = C1 * input + C3 * tmp1 + C5 * tmp2 + C7 * tmp3 + C9 * tmp4;

    return result_sin/result_cos;
}

static __device__ inline void translation_arcsin(float* input) {
    float tmp;
    tmp = *input;
    if (tmp < 0) {tmp = -tmp;}
    if (tmp > 0.62f){
        tmp = sqrt(1.0f - tmp * tmp);
    }
    *input = tmp;
}

// There is no feedback when the input is not [- 1, 1]
__device__ inline float asinf(float input) {
    float C1, C3, C5, C7, C9;
    taylor_arcsin(&C1, &C3, &C5, &C7, &C9);

    float input_ori = input;
    translation_arcsin(&input);  // The interval becomes [0, 0.62]

    float tmp0 = input * input;
    float tmp1 = tmp0 * input;
    float tmp2 = tmp1 * tmp0;
    float tmp3 = tmp2 * tmp0;
    float tmp4 = tmp3 * tmp0;
    float result = C1 * input + C3 * tmp1 + C5 * tmp2 + C7 * tmp3 + C9 * tmp4;

    if (input_ori > 0.62f || input_ori < -0.62f) {
        result = PI/2 - result;
    }
    if (input_ori < 0) {
        result = - result;
    }

    return result;
}

__device__ inline float acosf(float input) {
    float result = PI/2 - asinf(input);
    return result;
}

__device__ inline float atanf(float input) {
    input = input / sqrt(1.0f + input * input);
    float result = asinf(input);
    return result;
}

#define BUILTIN_DIV_F32(X, Y)           \
  ({                                    \
    float _div_x = X;                   \
    float _div_y = Y;                   \
    float _div_ret = _div_x / _div_y;   \
    _div_ret;                           \
  })

__attribute__((const)) __device__ float MATH_PRIVATE_F32_atanred(float v) {
  float t = v * v;
  float z = __builtin_fmaf(
      t,
      __builtin_fmaf(
          t,
          __builtin_fmaf(
              t,
              __builtin_fmaf(
                  t,
                  __builtin_fmaf(t, __builtin_fmaf(t, __builtin_fmaf(t, 0x1.5a54bp-9f, -0x1.f4b218p-7f), 0x1.53f67ep-5f),
                               -0x1.2fa9aep-4f),
                  0x1.b26364p-4f),
              -0x1.22c1ccp-3f),
          0x1.99717ep-3f),
      -0x1.5554c4p-2f);
  z = __builtin_fmaf(v, t * z, v);
  return z;
}

__device__ inline float atan2f(float y, float x) {
  const float pi = 0x1.921fb6p+1f;
  const float piby2 = 0x1.921fb6p+0f;
  const float piby4 = 0x1.921fb6p-1f;
  const float threepiby4 = 0x1.2d97c8p+1f;
  float ax = __builtin_fabsf(x);
  float ay = __builtin_fabsf(y);
  float v = __builtin_fminf(ax, ay);
  float u = __builtin_fmaxf(ax, ay);
  float vbyu = BUILTIN_DIV_F32(v, u);
  float a = MATH_PRIVATE_F32_atanred(vbyu);
  float t = piby2 - a;
  a = ay > ax ? t : a;
  t = pi - a;
  a = x < 0.0f ? t : a;
  t = ((int)(x)) < 0 ? pi : 0.0f;
  a = y == 0.0f ? t : a;
  return __builtin_copysignf(a, y);
}

__device__ inline float sinhf(float input) {
    float tmp = exp(input);
    float result = (tmp-1.0f/tmp)/2;
    return result;
}

__device__ inline float coshf(float input) {
    float tmp = exp(input);
    float result = (tmp+1.0f/tmp)/2;
    return result;
}

__device__ inline float tanhf(float input) {
    float tmp = exp(input);
    float result = (tmp-1.0f/tmp)/(tmp+1.0f/tmp);
    return result;
}

__device__ inline float32x16_t vtanhf(float32x16_t input) {
    int len = 16;
    __simd__ float input_lm[len];
    __simd__ float exp_lm[len];
    __simd__ float inv_exp_lm[len];
    vstore_lm_float32x16(input_lm, input);
    mfence_lm();
    for (int k = 0; k < len; k++) {
        float input_tmp = *(input_lm + k);
        float exp_tmp = exp(input_tmp);
        float inv_exp_tmp = 1 / exp_tmp;
        *(exp_lm + k) = exp_tmp;
        *(inv_exp_lm + k) = inv_exp_tmp;
    }
    mfence_lm();
    float32x16_t _exp = vload_lm_float32x16(exp_lm);
    float32x16_t _inv_exp = vload_lm_float32x16(inv_exp_lm);
    float32x16_t _sub = vvsub_float32x16(_exp, _inv_exp);
    float32x16_t _add = vvadd_float32x16(_exp, _inv_exp);
    vstore_lm_float32x16(exp_lm, _sub);
    vstore_lm_float32x16(inv_exp_lm, _add);
    mfence_lm();
    for (int k = 0; k < len; k++) {
        float sub_tmp = *(exp_lm + k);
        float add_tmp = *(inv_exp_lm + k);
        float res_tmp = sub_tmp / add_tmp;
        *(input_lm + k) = res_tmp;
    }
    mfence_lm();
    float32x16_t res = vload_lm_float32x16(input_lm);
    return res;
}

__device__ inline float16x32_t hvtanh(float16x32_t input) {
    float32x16_t vl_input = vfp162float_l(input);
    float32x16_t vh_input = vfp162float_h(input);
    float32x16_t vl_tanh = vcosf(vl_input);
    float32x16_t vh_tanh = vcosf(vh_input);
    float16x32_t v_tanh = vfloat2fp16_lh(vl_tanh, vh_tanh);
    return v_tanh;
}

__device__ inline float asinhf(float input) {
    float result = log(input + sqrt(1.0f + input * input));
    return result;
}

__device__ inline float acoshf(float input) {
    float result = log(input + sqrt(-1.0f + input * input));
    return result;
}

__device__ inline float atanhf(float input) {
    float result = log((1.0f + input)/(1.0f - input)) / 2;
    return result;
}

// other
__device__ inline float rsqrtf(float input) {
    return 1.0f / sqrt(input);
}

__device__ inline double rsqrtf(double input) {
    return 1.0f / sqrt(input);
}

__device__ inline float __fsqrt_rn(float __a) {
  float ret;
  asm volatile("sqrt.f.rn %0, %1" : "=r"(ret) : "r"(__a));
  return ret;
}

__device__ inline double __dsqrt_rn(double __a) {
  double dsqrt = sqrt(__a);
  double rounded_dsqrt = static_cast<double>(dsqrt);
  return rounded_dsqrt;
}

__device__ inline float32x16_t vrsqrtf(float32x16_t input) {
    int len = 16;
    __simd__ float input_lm[len];
    __simd__ float res_lm[len];
    vstore_lm_float32x16(input_lm, input);
    __builtin_xpu2_mfence(1);
    for (int k = 0; k < len; k++) {
        float input_tmp = *(input_lm + k);
        float rsqrt_tmp = rsqrtf(input_tmp);
        *(res_lm + k) = rsqrt_tmp;
    }
    __builtin_xpu2_mfence(1);
    float32x16_t res = vload_lm_float32x16(res_lm);
    return res;
}

static __device__ inline float32x16_t calc_fast_rsqrt(float32x16_t v0_l, int mask_l = -1) {
    float32x16_t v1_l, v2_l;
    // x2 = 0.5f * x
    v1_l = svmul_float32x16(0.5f, v0_l);
    // i = *(*long)(&x)
    // i = 0x5f3759df - (i >> 1)
    // y = *(float *)&i
    v0_l = reinterpret_cast<float32x16_t>(svsrl_int32x16(1, reinterpret_cast<int32x16_t>(v0_l)));
    v0_l = reinterpret_cast<float32x16_t>(svsub_int32x16(0x5f3759df, reinterpret_cast<int32x16_t>(v0_l)));
    // y = y * (1.5f - (x2 * y * y)), 迭代3次
    v2_l = vvmul_float32x16(v1_l, v0_l);
    v2_l = vvmul_float32x16(v0_l, v2_l);
    v2_l = svsub_float32x16(1.5f, v2_l);
    v0_l = vvmul_float32x16(v0_l, v2_l);
    v2_l = vvmul_float32x16(v1_l, v0_l);
    v2_l = vvmul_float32x16(v0_l, v2_l);
    v2_l = svsub_float32x16(1.5f, v2_l);
    v0_l = vvmul_float32x16(v0_l, v2_l);
    v2_l = vvmul_float32x16(v1_l, v0_l);
    v2_l = vvmul_float32x16(v0_l, v2_l);
    v2_l = svsub_float32x16(1.5f, v2_l);
    float32x16_t res = vvmul_float32x16_mz(v0_l, v2_l, mask_l);
    return res;
}

__device__ inline float32x16_t vrsqrtf_fast(float32x16_t v0_l) {
    int ge_zero_mask_l = svle_float32x16(0.0f, v0_l);
    int neq_inf_mask_l = svneq_float32x16(std::numeric_limits<float>::infinity(), v0_l);
    int eq_zero_mask_l = sveq_float32x16(0.0f, v0_l);
    float32x16_t v0_l_or_inf = svor_float32x16_mz(std::numeric_limits<float>::infinity(), v0_l, eq_zero_mask_l);
    int no_modified_flag_all_l = ~((~ge_zero_mask_l) | (~neq_inf_mask_l) | (eq_zero_mask_l));
    float32x16_t calc_res = calc_fast_rsqrt(v0_l, no_modified_flag_all_l);
    calc_res = vvor_float32x16(calc_res, v0_l_or_inf);
    float32x16_t res = svor_float32x16_mh(std::numeric_limits<float>::quiet_NaN(), (calc_res), (calc_res), ~ge_zero_mask_l);
    return res;
}

__device__ inline float pow(float input1, float input2) {
    float ret;
    float mul_res;
    float log_res;
    if (input1 > 0.0f) {
      log_res = __builtin_xpu_log2f(input1);
      mul_res = __builtin_xpu_mulf(log_res, input2);
      ret = __builtin_xpu_exp2f(mul_res);
    } else if ((input1 < 0.0f) && (rint(input2) != input2)) { // intput1 is negative and input2 is not integer
      ret = __builtin_nanf ("");
    } else if (input2 == 0.0f) {
      ret = 1.0f;
    } else if (input1 == 0.0f && input2 > 0.0f) {
      ret = 0.0f;
    } else if (input1 == 0.0f && input2 < 0.0f) {
      ret = __builtin_inff();
    } else if (rint(0.5f * input2) == (0.5f * input2)) { // input2 is even
      log_res = __builtin_xpu_log2f(-input1);
      mul_res = __builtin_xpu_mulf(log_res, input2);
      ret = __builtin_xpu_exp2f(mul_res);
    } else {
      log_res = __builtin_xpu_log2f(-input1);
      mul_res = __builtin_xpu_mulf(log_res, input2);
      ret = -__builtin_xpu_exp2f(mul_res);
    }
    return ret;
}

__device__ inline int32_t ffs(int32_t x) {
    if (x == 0) return 0;

    int32_t position = 1;

    // Check lower half (16 bits)
    if ((x & 0x0000FFFF) == 0) {
        x >>= 16;
        position += 16;
    }
    // Check lower 8 bits of the current half
    if ((x & 0x000000FF) == 0) {
        x >>= 8;
        position += 8;
    }
    // Check lower 4 bits of the current quarter
    if ((x & 0x0000000F) == 0) {
        x >>= 4;
        position += 4;
    }
    // Check lower 2 bits of the current nibble
    if ((x & 0x00000003) == 0) {
        x >>= 2;
        position += 2;
    }
    // Check the lowest bit of the current pair
    if ((x & 0x00000001) == 0) {
        position += 1;
    }

    return position;
}

__device__ inline float log1pf(float input) {
    return log(input + 1.0f);
}

__device__ inline float expm1f(float input) {
    return exp(input) - 1.0f;
}

__device__  inline uint64_t asuint64(double f) {
  union {
    double _f;
    uint64_t _i;
  } u;
  u._f = f;
  return u._i;
}

/* Top 12 bits of a double (sign and exponent bits).  */
__device__ inline uint32_t top12(double x) {
    return asuint64(x) >> 52;
}

__device__ inline uint32_t asuint(float f) {
  union {
    float _f;
    uint32_t _i;
  } u;
  u._f = f;
  return u._i;
}

__device__ inline double eval_as_double(double x) {
  double y = x;
  return y;
}

__device__  inline double asdouble(uint64_t i) {
  union {
    uint64_t _i;
    double _f;
  } u;
  u._i = i;
  return u._f;
}

__device__ inline float eval_as_float(float x) {
  float y = x;
  return y;
}

__device__ inline float exp2f(float x) {
    int N = 32;
    uint32_t abstop;
    uint64_t ki, t;
    double kd, xd, z, r, r2, y, s;
    uint64_t T[32] = {
        0x3ff0000000000000, 0x3fefd9b0d3158574, 0x3fefb5586cf9890f, 0x3fef9301d0125b51, 0x3fef72b83c7d517b,
        0x3fef54873168b9aa, 0x3fef387a6e756238, 0x3fef1e9df51fdee1, 0x3fef06fe0a31b715, 0x3feef1a7373aa9cb,
        0x3feedea64c123422, 0x3feece086061892d, 0x3feebfdad5362a27, 0x3feeb42b569d4f82, 0x3feeab07dd485429,
        0x3feea47eb03a5585, 0x3feea09e667f3bcd, 0x3fee9f75e8ec5f74, 0x3feea11473eb0187, 0x3feea589994cce13,
        0x3feeace5422aa0db, 0x3feeb737b0cdc5e5, 0x3feec49182a3f090, 0x3feed503b23e255d, 0x3feee89f995ad3ad,
        0x3feeff76f2fb5e47, 0x3fef199bdd85529c, 0x3fef3720dcef9069, 0x3fef5818dcfba487, 0x3fef7c97337b9b5f,
        0x3fefa4afa2a490da, 0x3fefd0765b6e4540,
    };
    double SHIFT = 0x1.8p+52 / N;
    xd = (double)x;
    abstop = top12(x) & 0x7ff;
    if (predict_false(abstop >= top12(128.0f))) {
        /* |x| >= 128 or x is nan.  */
        if (asuint(x) == asuint(-INFINITY))
        return 0.0f;
        if (abstop >= top12(INFINITY))
        return x + x;
        if (x > 0.0f)
        return 0;
        if (x <= -150.0f)
        return 0;
    }

    /* x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.  */
    kd = eval_as_double(xd + SHIFT);
    ki = asuint64(kd);
    kd -= SHIFT; /* k/N for int k.  */
    r = xd - kd;

    /* exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1) */
    t = T[ki % N];
    t += ki << (52 - 5);
    s = asdouble(t);
    z = 0x1.c6af84b912394p-5 * r + 0x1.ebfce50fac4f3p-3;
    r2 = r * r;
    y = 0x1.62e42ff0c52d6p-1 * r + 1;
    y = z * r2 + y;
    y = y * s;
    return eval_as_float(y);
}

__device__ inline float roundf(float input) {
    return (input > 0.0) ? floor(input + 0.5) : ceil(input - 0.5);
}

__device__ inline float log2f(float input) {
    return log(input) / LN2;
}

__device__ inline float log10f(float input) {
    return log(input) / LN10;
}

__device__ inline float xpu_sqrt(float input) {
    return sqrt(input);
}

__device__ inline double xpu_sqrt(double input) {
    return sqrt(input);
}

__device__ inline float xpu_floor(float input) {
    return floor(input);
}

__device__ inline double xpu_floor(double input) {
    return floor(input);
}

__device__ inline float xpu_ceil(float input) {
    return ceil(input);
}

__device__ inline double xpu_ceil(double input) {
    return ceil(input);
}

__device__ inline int32_t xpu_min(int32_t a, int32_t b) {
    return min(a, b);
}

__device__ inline uint32_t xpu_min(uint32_t a, uint32_t b) {
    return min(a, b);
}

__device__ inline int64_t xpu_min(int64_t a, int64_t b) {
    return min(a, b);
}

__device__ inline uint64_t xpu_min(uint64_t a, uint64_t b) {
    return min(a, b);
}

__device__ inline float xpu_min(float a, float b) {
    return min(a, b);
}

__device__ inline double xpu_min(double a, double b) {
    return min(a, b);
}

__device__ inline int32_t xpu_max(int32_t a, int32_t b) {
    return max(a, b);
}

__device__ inline uint32_t xpu_max(uint32_t a, uint32_t b) {
    return max(a, b);
}

__device__ inline int64_t xpu_max(int64_t a, int64_t b) {
    return max(a, b);
}

__device__ inline uint64_t xpu_max(uint64_t a, uint64_t b) {
    return max(a, b);
}

__device__ inline float xpu_max(float a, float b) {
    return max(a, b);
}

__device__ inline double xpu_max(double a, double b) {
    return max(a, b);
}

__device__ inline float fma(float x, float y, float z) {
    return x * y + z;
}

__device__ inline float erf(float x) {
    float a1 =  0.254829592;
    float a2 = -0.284496736;
    float a3 =  1.421413741;
    float a4 = -1.453152027;
    float a5 =  1.061405429;
    float p  =  0.3275911;

    int sign = 1;
    if (x < 0) {
        sign = -1;
    }
    x = fabs(x);

    float t = 1.0 / (1.0 + p * x);
    float y = (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t;
    float result = 1 - (y * exp(-x * x));
    return sign * result;
}

__device__ inline float erfc(float x) {
    return 1.0f - erf(x);
}

 __device__ inline float erfinv(float x) {
    if (x < -1.0f || x > 1.0f) {
        return __builtin_nanf("");
    } else if (x == 1.0f) {
        return INFINITY;
    } else if (x == -1.0f) {
        return -INFINITY;
    }

    float a0 = 1.1975323115670912564578e0;
    float a1 = 4.7072688112383978012285e1;
    float a2 = 6.9706266534389598238465e2;
    float a3 = 4.8548868893843886794648e3;
    float a4 = 1.6235862515167575384252e4;
    float a5 = 2.3782041382114385731252e4;
    float a6 = 1.1819493347062294404278e4;
    float a7 = 8.8709406962545514830200e2;

    float b0 = 1.0000000000000000000e0;
    float b1 = 4.2313330701600911252e1;
    float b2 = 6.8718700749205790830e2;
    float b3 = 5.3941960214247511077e3;
    float b4 = 2.1213794301586595867e4;
    float b5 = 3.9307895800092710610e4;
    float b6 = 2.8729085735721942674e4;
    float b7 = 5.2264952788528545610e3;

    float c0 = 1.42343711074968357734e0;
    float c1 = 4.63033784615654529590e0;
    float c2 = 5.76949722146069140550e0;
    float c3 = 3.64784832476320460504e0;
    float c4 = 1.27045825245236838258e0;
    float c5 = 2.41780725177450611770e-1;
    float c6 = 2.27238449892691845833e-2;
    float c7 = 7.74545014278341407640e-4;

    float d0 = 1.4142135623730950488016887e0;
    float d1 = 2.9036514445419946173133295e0;
    float d2 = 2.3707661626024532365971225e0;
    float d3 = 9.7547832001787427186894837e-1;
    float d4 = 2.0945065210512749128288442e-1;
    float d5 = 2.1494160384252876777097297e-2;
    float d6 = 7.7441459065157709165577218e-4;
    float d7 = 1.4859850019840355905497876e-9;

    float e0 = 6.65790464350110377720e0;
    float e1 = 5.46378491116411436990e0;
    float e2 = 1.78482653991729133580e0;
    float e3 = 2.96560571828504891230e-1;
    float e4 = 2.65321895265761230930e-2;
    float e5 = 1.24266094738807843860e-3;
    float e6 = 2.71155556874348757815e-5;
    float e7 = 2.01033439929228813265e-7;

    float f0 = 1.414213562373095048801689e0;
    float f1 = 8.482908416595164588112026e-1;
    float f2 = 1.936480946950659106176712e-1;
    float f3 = 2.103693768272068968719679e-2;
    float f4 = 1.112800997078859844711555e-3;
    float f5 = 2.611088405080593625138020e-5;
    float f6 = 2.010321207683943062279931e-7;
    float f7 = 2.891024605872965461538222e-15;

    float abs_x = fabs(x);

    if (abs_x <= 0.85f) {
        float r = 0.180625f - 0.25f * x * x;
        float num = (((((((a7 * r + a6) * r + a5) * r + a4) * r + a3) * r + a2) * r + a1) * r + a0);
        float den = (((((((b7 * r + b6) * r + b5) * r + b4) * r + b3) * r + b2) * r + b1) * r + b0);
        return x * num / den;
    }

    float r = sqrt(LN2 - log(1.0f - abs_x));

    float num, den;
    if (r <= 5.0f) {
        r = r - 1.6f;
        num = (((((((c7 * r + c6) * r + c5) * r + c4) * r + c3) * r + c2) * r + c1) * r + c0);
        den = (((((((d7 * r + d6) * r + d5) * r + d4) * r + d3) * r + d2) * r + d1) * r + d0);
    } else {
        r = r - 5.0f;
        num = (((((((e7 * r + e6) * r + e5) * r + e4) * r + e3) * r + e2) * r + e1) * r + e0);
        den = (((((((f7 * r + f6) * r + f5) * r + f4) * r + f3) * r + f2) * r + f1) * r + f0);
    }

    float sign = x >= 0.0f ? 1.0f : -1.0f;
    return num / den * sign;
}

__device__ inline float32x16_t verf(float32x16_t vl) {
    // 定义 erf 中使用的常数
    float a1 =  0.254829592;
    float a2 = -0.284496736;
    float a3 =  1.421413741;
    float a4 = -1.453152027;
    float a5 =  1.061405429;
    float p  =  0.3275911;

    __simd__ float expx2[16];
    __simd__ float t[16];
    float32x16_t tmp1, tmp2, tmp;
    int signl;

    // 计算 x 的平方
    tmp1 = vvmul_float32x16(vl, vl);
    vstore_lm_float32x16(expx2, tmp1);

    // 计算 |x|
    signl = svlt_float32x16(0, vl);    // x>0
    tmp1 = svmul_float32x16_mz(1, vl, signl);
    tmp2 = svmul_float32x16_mz(-1, vl, ~signl);
    tmp = vvadd_float32x16(tmp1, tmp2);
    vstore_lm_float32x16(t, tmp);

    // 计算 t = 1.0 / (1.0 + p * |x|)
    mfence_lm();
    for (int k = 0; k < 16; k++) {
        expx2[k] = exp(-expx2[k]);
        t[k] = 1.0f / (1.0f + p * t[k]);
    }
    mfence_lm();

    // 计算 erf 多项式 (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t
    vl = vload_lm_float32x16(t);
    tmp1 = svmul_float32x16(a5, vl);
    tmp1 = svadd_float32x16(a4, tmp1);
    tmp1 = vvmul_float32x16(tmp1, vl);
    tmp1 = svadd_float32x16(a3, tmp1);
    tmp1 = vvmul_float32x16(tmp1, vl);
    tmp1 = svadd_float32x16(a2, tmp1);
    tmp1 = vvmul_float32x16(tmp1, vl);
    tmp1 = svadd_float32x16(a1, tmp1);
    tmp1 = vvmul_float32x16(tmp1, vl);

    // 计算 *exp(-x^2)
    vl = vload_lm_float32x16(expx2);
    vl = vvmul_float32x16(vl, tmp1);
    vl = svsub_float32x16(1, vl);

    // sign ? y : -y
    tmp1 = svmul_float32x16_mz(1, vl, signl);
    tmp2 = svmul_float32x16_mz(-1, vl, ~signl);
    vl = vvadd_float32x16(tmp1, tmp2);

    return vl;
}

#define CHAR_BIT  8
typedef int32_t si_int;
typedef uint32_t su_int;
typedef int64_t di_int;
typedef uint64_t du_int;

typedef union {
  di_int all;
  struct {
    su_int low;
    si_int high; // _YUGA_LITTLE_ENDIAN
  } s;
} dwords;

static __device__ inline di_int __muldsi3(su_int a, su_int b) {
  dwords r;
  const int bits_in_word_2 = (int)(sizeof(si_int) * CHAR_BIT) / 2;
  const su_int lower_mask = (su_int)~0 >> bits_in_word_2;
  r.s.low = (a & lower_mask) * (b & lower_mask);
  su_int t = r.s.low >> bits_in_word_2;
  r.s.low &= lower_mask;
  t += (a >> bits_in_word_2) * (b & lower_mask);
  r.s.low += (t & lower_mask) << bits_in_word_2;
  r.s.high = t >> bits_in_word_2;
  t = r.s.low >> bits_in_word_2;
  r.s.low &= lower_mask;
  t += (b >> bits_in_word_2) * (a & lower_mask);
  r.s.low += (t & lower_mask) << bits_in_word_2;
  r.s.high += t >> bits_in_word_2;
  r.s.high += (a >> bits_in_word_2) * (b >> bits_in_word_2);
  return r.all;
}

static __device__ inline di_int __muldi3(di_int a, di_int b) {
  dwords x;
  x.all = a;
  dwords y;
  y.all = b;
  dwords r;
  r.all = __muldsi3(x.s.low, y.s.low);
  r.s.high += x.s.high * y.s.low + x.s.low * y.s.high;
  return r.all;
}

__device__ inline int32_t mulhi (int32_t a, int32_t b) {
    int64_t product = __muldi3((int64_t)a, (int64_t)b);
    int32_t high_part = (int32_t)(product >> 32);
    return high_part;
}

__device__ inline uint32_t umulhi (uint32_t a, uint32_t b) {
    int64_t product = __muldi3((int64_t)a, (int64_t)b);
    uint32_t high_part = (uint32_t)(product >> 32);
    return high_part;
}


__device__ inline uint32_t __FLOAT_BITS(float __f) {
  union {
    float __f;
    uint32_t __i;
  } __u;
  __u.__f = __f;
  return __u.__i;
}

__device__ inline int32_t isnan(float x) {
    return (__FLOAT_BITS(x) & 0x7fffffffU) > 0x7f800000U;
}

__device__ inline int32_t isinf(float __a) {
    uint32_t bits = *reinterpret_cast<uint32_t *>(&__a);
    uint32_t exponentMask = 0x7F800000U;
    uint32_t fractionMask = 0x007FFFFFU;
    uint32_t exponent = bits & exponentMask;
    uint32_t fraction = bits & fractionMask;
    return (exponent == exponentMask) && (fraction == 0);
}

__device__ inline int32x16_t visinf(float32x16_t vx0) {
    vx0 = reinterpret_cast<float32x16_t>(svand_int32x16(0x7FFFFFFF, reinterpret_cast<int32x16_t>(vx0)));
    int32x16_t mask0 = sveq_int32x16(0x7F800000, reinterpret_cast<int32x16_t>(vx0));
    return mask0;
}

__device__ inline int32_t finitef(float __a) {
  unsigned int *valueAsBits = reinterpret_cast<unsigned int *>(&__a);
  unsigned int exponentMask = 0x7F800000U;
  unsigned int fractionMask = 0x007FFFFFU;
  unsigned int exponent = (*valueAsBits) & exponentMask;
  unsigned int fraction = (*valueAsBits) & fractionMask;
  return (exponent != exponentMask) || (fraction != 0) && (exponent == 0);
}


__device__ inline float __fdiv_rn(float __a, float __b) {
  float ret;
  asm volatile("div.f.rn %0, %1, %2" : "=r"(ret) : "r"(__a), "r"(__b));
  return ret;
}

__device__ inline double __ddiv_rn(double __a, double __b) {
  double div = __a / __b;
  double rounded_div = static_cast<double>(div);
  return rounded_div;
}

__device__ inline float __fdiv_rz(float __a, float __b) {
  float ret;
  asm volatile("div.f.rz %0, %1, %2" : "=r"(ret) : "r"(__a), "r"(__b));
    return ret;
}


__device__ inline double __ddiv_rz(double __a, double __b) {
  double div = __a / __b;
  double rounded_div = static_cast<double>(div);
  return rounded_div;
}

__device__ inline float __fdiv_rd(float __a, float __b) {
  float ret;
  asm volatile("div.f.rd %0, %1, %2" : "=r"(ret) : "r"(__a), "r"(__b));
  return ret;
}

__device__ inline double __ddiv_rd(double __a, double __b) {
  double div = __a / __b;
  double rounded_div = static_cast<double>(div);
  return rounded_div;
}

__device__ inline float truncf(float input) { return __builtin_truncf(input); }

__device__ inline double trunc(double x) {
  union {
    double f;
    uint64_t i;
  } u = {x};
  int e = (int)(u.i >> 52 & 0x7ff) - 0x3ff + 12;
  uint64_t m;
  if (e >= 52 + 12)
    return x;
  if (e < 12)
    e = 1;
  m = -1ULL >> e;
  if ((u.i & m) == 0)
    return x;
  u.i &= ~m;
  return u.f;
}


__device__ inline float xpu_trunc(float x, float y) {
  float output_temp1 = x / y;
  float z = floor(output_temp1);
  float output_temp2 = fabs(z);
  z = z + output_temp2;
  z = z / 2;

  output_temp1 = -output_temp1;
  output_temp1 = floor(output_temp1);
  output_temp2 = fabs(output_temp1);
  output_temp1 = output_temp1 + output_temp2;
  output_temp1 = output_temp1 / 2;
  output_temp1 = -output_temp1;
  z = z + output_temp1;
  return z;
}

__device__ inline bool isnanf(float x) { return __builtin_isnan(x); }

__device__ inline float fmodf(float x, float y) {
  union {
    float f;
    unsigned i;
  } ux = {x}, uy = {y};
  int ex = ux.i >> 23 & 0xff;
  int ey = uy.i >> 23 & 0xff;
  unsigned sx = ux.i & 0x80000000;
  unsigned i;
  unsigned uxi = ux.i;

  if (uy.i << 1 == 0 || isnanf(y) || ex == 0xff)
    return (x * y) / (x * y);
  if (uxi << 1 <= uy.i << 1) {
    if (uxi << 1 == uy.i << 1)
      return 0 * x;
    return x;
  }

  /* normalize x and y */
  if (!ex) {
    for (i = uxi << 9; i >> 31 == 0; ex--, i <<= 1)
      ;
    uxi <<= -ex + 1;
  } else {
    uxi &= -1U >> 9;
    uxi |= 1U << 23;
  }
  if (!ey) {
    for (i = uy.i << 9; i >> 31 == 0; ey--, i <<= 1)
      ;
    uy.i <<= -ey + 1;
  } else {
    uy.i &= -1U >> 9;
    uy.i |= 1U << 23;
  }

  /* x mod y */
  for (; ex > ey; ex--) {
    i = uxi - uy.i;
    if (i >> 31 == 0) {
      if (i == 0)
        return 0 * x;
      uxi = i;
    }
    uxi <<= 1;
  }
  i = uxi - uy.i;
  if (i >> 31 == 0) {
    if (i == 0)
      return 0 * x;
    uxi = i;
  }
  for (; uxi >> 23 == 0; uxi <<= 1, ex--)
    ;

  /* scale result up */
  if (ex > 0) {
    uxi -= 1U << 23;
    uxi |= (unsigned)ex << 23;
  } else {
    uxi >>= -ex + 1;
  }
  uxi |= sx;
  ux.i = uxi;
  return ux.f;
}


__device__ inline int __signbitf(float a) {
  return a < 0.f;
}

// ge
__device__ inline uint32_t vvgefp32(float32x16_t vx, float32x16_t vy) {
  uint32_t mask = (static_cast<uint32_t>(vvle_float32x16(vy, vx)) & 0x0000FFFF);
  return mask;
}

__device__ inline uint32_t vvgefp16(float16x32_t vx, float16x32_t vy) {
  uint32_t mask = static_cast<uint32_t>(vvle_float16x32(vy, vx));
  return mask;
}

// le
__device__ inline uint32_t vvlefp32(float32x16_t vx, float32x16_t vy) {
  uint32_t mask = (~static_cast<uint32_t>(vvlt_float32x16(vy, vx)) & 0x0000FFFF);
  return mask;
}

__device__ inline uint32_t vvlefp16(float16x32_t vx, float16x32_t vy) {
  uint32_t mask = static_cast<uint32_t>(~vvlt_float16x32(vy, vx));
  return mask;
}

// lt
__device__ inline uint32_t vvltfp32(float32x16_t vx, float32x16_t vy) {
  uint32_t mask = (static_cast<uint32_t>(vvlt_float32x16(vx, vy)) & 0x0000FFFF);
  return mask;
}

__device__ inline uint32_t vvltfp16(float16x32_t vx, float16x32_t vy) {
  uint32_t mask = static_cast<uint32_t>(vvlt_float16x32(vx, vy));
  return mask;
}

// gt
__device__ inline uint32_t vvgtfp32(float32x16_t vx, float32x16_t vy) {
  uint32_t mask = (static_cast<uint32_t>(vvlt_float32x16(vy, vx)) & 0x0000FFFF);
  return mask;
}

__device__ inline uint32_t vvgtfp16(float16x32_t vx, float16x32_t vy) {
  uint32_t mask = static_cast<uint32_t>(vvlt_float16x32(vy, vx));
  return mask;
}

// ne
__device__ inline uint32_t vvnefp32(float32x16_t vx, float32x16_t vy) {
  uint32_t mask = (static_cast<uint32_t>(vvneq_float32x16(vy, vx)) & 0x0000FFFF);
  return mask;
}

__device__ inline uint32_t vvnefp16(float16x32_t vx, float16x32_t vy) {
  uint32_t mask = static_cast<uint32_t>(vvneq_float16x32(vy, vx));
  return mask;
}

__device__ inline void vstorei8(uint32_t mask0, uint32_t mask1, uint32_t mask2, uint32_t mask3, int8_t* z) {
  int8x64_t res(0x01);
  unsigned long long mask = mask0 | 0x0000000000000000;
  unsigned long long mask_tmp = mask2 | 0x0000000000000000;
  mask1 = mask1 << 16;
  mask = mask1 | mask;
  mask3 = mask3 << 16;
  mask_tmp = mask3 | mask_tmp;
  mask_tmp = mask_tmp << 32;
  mask = mask_tmp | mask;
  vstore_lm_int8x64_mz(z, res, mask);
}

// float16
#ifdef __arch_xpu3__
__device__ inline float fp16tofp32(float16 input) {
    __simd__ float16 _input[32] = {input};
    __simd__ float _input_fp32[32];
    fp16tofp32(_input, _input_fp32, 1);
    return _input_fp32[0];
}

__device__ inline float16 fp32tofp16(float input) {
    __simd__ float _input[32] = {input};
    __simd__ float16 _input_fp16[32];
    fp32tofp16(_input, _input_fp16, 1);
    return _input_fp16[0];
}

__device__ inline float16 hsin(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = sinf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hcos(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = cosf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 htan(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = tanf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hasin(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = asinf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hacos(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = acosf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 htanh(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = tanhf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hasinh(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = asinhf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hacosh(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = acoshf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hatanh(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = atanhf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hrsqrt(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = rsqrtf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hpow(float16 input1, float16 input2) {
    float input1_fp32 = fp16tofp32(input1);
    float input2_fp32 = fp16tofp32(input2);
    float result_fp32 = pow(input1_fp32, input2_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hexpm1(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = expm1f(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hexp2(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = exp2f(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hlog2(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = log2f(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 hlog10(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = log10f(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 xpu_hfloor(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = xpu_floor(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 xpu_hceil(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = xpu_ceil(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 xpu_hmin(float16 input1, float16 input2) {
    float input1_fp32 = fp16tofp32(input1);
    float input2_fp32 = fp16tofp32(input2);
    float result_fp32 = xpu_min(input1_fp32, input2_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 xpu_hmax(float16 input1, float16 input2) {
    float input1_fp32 = fp16tofp32(input1);
    float input2_fp32 = fp16tofp32(input2);
    float result_fp32 = xpu_max(input1_fp32, input2_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline float16 herf(float16 input) {
    float input_fp32 = fp16tofp32(input);
    float result_fp32 = erf(input_fp32);
    return fp32tofp16(result_fp32);
}

__device__ inline int32_t hisnan(float16 input) {
    float input_fp32 = fp16tofp32(input);
    int32_t result_fp32 = isnan(input_fp32);
    return result_fp32;
}

__device__ inline int32_t hisin(float16 input) {
    float input_fp32 = fp16tofp32(input);
    int32_t result_fp32 = isinf(input_fp32);
    return result_fp32;
}

__device__ inline int32_t hfinite(float16 input) {
    float input_fp32 = fp16tofp32(input);
    int32_t result_fp32 = finitef(input_fp32);
    return result_fp32;
}


// borrowed from xtrans include/xpu/kernel/atomic.h
#define GM_BASE_ADDR 0x4000000000
#define NOP_TIME 5

__attribute__((weak)) __device__ int XTransSpinLock = 0;

__attribute__((used)) __device__ void xtransLock() {
  int nop_time = NOP_TIME;
  // 使用amoadd获取返回值，如果不为0的话，则一直循环，直到获取到锁为止，在里面设置一些nop来减少竞争
  while (__builtin_xpu_amoadd(1, &XTransSpinLock) != 0) {
    for (int i = 0; i < nop_time; i++) {
      __asm __volatile__("nop");
    }
    nop_time += NOP_TIME;
  }
}

__attribute__((used)) __device__ inline void xtransUnlock() {
  // 释放锁就是将锁置为0
  __builtin_xpu_amoswap(0, &XTransSpinLock);
}

__device__ float atomicAdd(__global_ptr__ float *address, float val) {
  if ((long)address >= GM_BASE_ADDR) {
    xtransLock();
    float x = *address;
    *address = x + val;
    xtransUnlock();
    return x;
  } else {
    ticket_lock_mix();
    float x = *address;
    *address = x + val;
    ticket_unlock_mix();
    return x;
  }
}

__device__ float16 atomicAdd(__global_ptr__ float16 *address, float16 val) {
  if ((long)address >= GM_BASE_ADDR) {
    xtransLock();
    float16 x = *address;
    *address = __hadd(x, val);
    xtransUnlock();
    return x;
  } else {
    ticket_lock_mix();
    float16 x = *address;
    *address = __hadd(x, val);
    ticket_unlock_mix();
    return x;
  }
}


__device__ float atomicMul(__global_ptr__ float *address, float val) {
  if ((long)address >= GM_BASE_ADDR) {
    xtransLock();
    float x = *address;
    *address = x * val;
    xtransUnlock();
    return x;
  } else {
    ticket_lock_mix();
    float x = *address;
    *address = x * val;
    ticket_unlock_mix();
    return x;
  }
}

__device__ float16 atomicMul(__global_ptr__ float16 *address, float16 val) {
  if ((long)address >= GM_BASE_ADDR) {
    xtransLock();
    float16 x = *address;
    *address = __hmul(x, val);
    xtransUnlock();
    return x;
  } else {
    ticket_lock_mix();
    float16 x = *address;
    *address = __hmul(x, val);
    ticket_unlock_mix();
    return x;
  }
}

__device__ uint8_t fp32_to_fp8_e4m3_fnuz_rne(float f) {
    // 通过 union 重解释浮点数，避免 memcpy
    union { float f; uint32_t u; } v = { f };
    uint32_t bits = v.u;
    uint32_t sign = bits >> 31;                       // 提取符号
    int32_t exp = ((bits >> 23) & 0xFF) - 127;          // 去偏后的FP32指数

    // FP8 E4M3 的有效指数范围为 [-6, 7]，超出部分直接饱和或冲零
    if(exp > 7) return (uint8_t)((sign << 7) | 0x7F);   // 溢出，返回最大值（符号位不变）
    if(exp < -6) return (uint8_t)(sign << 7);           // 下溢，冲零

    int new_exp = exp + 7;                            // 重新偏移为 FP8 的指数（偏移 7）
    // 取出 FP32 尾数并加上隐含的 1
    uint32_t sig = (bits & 0x7FFFFF) | 0x800000;
    // 为 FP8，我们只需要 4 位：1位隐含整数部分+3位尾数
    // 这里先右移 20 位，余下的低 20 位用于舍入判断
    uint32_t base = sig >> 20;            // 初步截断后的 4 位
    uint32_t r = sig & ((1u << 20) - 1);    // 余下的 20 位
    const uint32_t half = 1u << 19;         // 舍入位（中间值）

    // 计算舍入增量：round-to-nearest-even
    // 若余数大于 half 或等于 half 且低位为奇数，则加 1
    uint32_t incr = ((r > half) || ((r == half) && (base & 1))) ? 1 : 0;
    base += incr;

    // 如果舍入后进位溢出 4 位，则右移一位并调整指数
    if(base >= 16) {
        base >>= 1;
        new_exp++;
    }
    return (uint8_t)((sign << 7) | (new_exp << 3) | (base & 0x7));
}

__device__ uint8_t fp32_to_fp8_e5m2_funz_rne(float f) {
    // 通过 union 重解释浮点数，避免 memcpy 带来的开销
    union { float f; uint32_t u; } v = { f };
    uint32_t bits = v.u;
    uint32_t sign = bits >> 31;                   // 提取符号
    int32_t exp = ((bits >> 23) & 0xFF) - 127;      // FP32 去偏指数
    uint32_t mant = bits & 0x7FFFFF;                // FP32 尾数

    // FP8 E5M2 的有效正规数范围对应 FP32 指数 e ∈ [-14, 15]
    if(exp > 15)
        // 超出最大值时饱和为最大有限值：符号不变，指数设为 30（即 15+15-1），尾数全 1
        return (uint8_t)((sign << 7) | ((30 << 2) | 0x3));
    if(exp < -14)
        // 下溢：直接冲零（FUNZ规则，不产生子正规数）
        return (uint8_t)(sign << 7);

    // 重新偏移 FP8 指数：new_exp = e + 15
    int new_exp = exp + 15;

    // 组合隐含1与 FP32 尾数得到 24 位有效数字
    uint32_t sig = (1u << 23) | mant;
    // 为 FP8 E5M2，我们需要 3 位精度（1隐含位 + 2尾数位），故右移 (24 - 3) = 21 位
    uint32_t base = sig >> 21;
    // 余下的 21 位用于判断舍入
    uint32_t r = sig & ((1u << 21) - 1);
    const uint32_t half = 1u << 20;  // 舍入中间值

    // round-to-nearest-even 舍入
    if ((r > half) || ((r == half) && (base & 1))) {
        base++;
        // 若舍入导致隐含位溢出（3位数溢出为 4 位），则右移一位并增加指数
        if (base == 8) {
            base >>= 1;
            new_exp++;
            // 若指数溢出，则饱和为最大有限值
            if (new_exp >= 31)
                return (uint8_t)((sign << 7) | ((30 << 2) | 0x3));
        }
    }
    // 最终 FP8 E5M2 结果：符号 | (new_exp << 2) | (低2位为尾数)
    return (uint8_t)((sign << 7) | (new_exp << 2) | (base & 0x3));
}

__device__ float fp8e4m3_fnuz_to_fp32(uint8_t fp8) {
    // 提取各字段：1 位符号，4 位指数，3 位尾数
    uint32_t sign = fp8 >> 7;         // 最高位为符号位
    uint32_t exp  = (fp8 >> 3) & 0xF;   // 接下来 4 位为指数
    uint32_t mant = fp8 & 0x7;         // 低 3 位为尾数

    union {
        uint32_t u;
        float f;
    } out;

    if(exp == 0) {
        // FP8中零或下溢（FNUZ），直接转换为 0（符号保留）
        out.u = sign << 31;
    } else {
        // FP8 的指数偏移为 7，FP32 的指数偏移为 127，两者相差 120
        uint32_t new_exp = exp + 120;
        // FP8 的尾数 3 位，转换到 FP32 需放到最高的 3 位（左移 20 位）
        uint32_t new_mant = mant << 20;
        out.u = (sign << 31) | (new_exp << 23) | new_mant;
    }
    return out.f;
}

__device__ float fp8e5m2_fnuz_to_fp32(uint8_t fp8) {
    // 提取符号、指数和尾数
    uint32_t sign = fp8 >> 7;           // 最高位为符号位
    uint32_t exp  = (fp8 >> 2) & 0x1F;    // 接下来 5 位为指数
    uint32_t mant = fp8 & 0x3;            // 低 2 位为尾数

    union {
        uint32_t u;
        float f;
    } out;

    if(exp == 0) {
        // 下溢，直接返回 0（保留符号）
        out.u = sign << 31;
    } else {
        // FP8 E5M2 的正规数转换：
        // FP32 指数 = exp + 112 （因为 127 - 15 = 112）
        uint32_t new_exp = exp + 112;
        // 将 FP8 尾数左移 21 位（23-2）填入 FP32 尾数域
        uint32_t new_mant = mant << 21;
        out.u = (sign << 31) | (new_exp << 23) | new_mant;
    }
    return out.f;
}

__device__ int32_t findCacheIndex(int32_t *cache_index, int32_t bufNum, int32_t offset) {
    for (int i = 0; i < bufNum; i++) {
        if (offset == cache_index[i + 1]) {
            cache_index[0] = i;
            return 1;
        }
    }
    int result_index = cache_index[0] % bufNum;
    cache_index[0] = result_index;
    // first cached index is the result index
    cache_index[result_index + 1] = offset;
    return 0;
}

__device__ void printTensorFloat(_shared_ptr_ float *tensor, int32_t m, int32_t n, int32_t stride_n) {
    int cid = core_id();
    int cls_id = cluster_id();
    if (cls_id == __CHECK_CLUSTER_ID) {
        printf("\nprintTensorFp32 cluster_id=%d core_id=%d, {%d %d, s %d}\n", cls_id, cid, m, n, stride_n);
        int step = (m + 15) / 16;
        for (int32_t i = 0; i < m; i+=step) {
            printf("%d,%d/m{%d}[", cls_id, cid, i);
            for (int32_t j = 0; j < min(8, n); j++) {
                printf("%6.1f ", tensor[i * stride_n + j]);
            }
            printf("]\n");
        }
    }
}

__device__ void printTensorFloat16(_shared_ptr_ float16 *tensor, int32_t m, int32_t n, int32_t stride_n) {
    int cid = core_id();
    int cls_id = cluster_id();
    if (cls_id == __CHECK_CLUSTER_ID) {
        printf("\nprintTensorFp16 cluster_id=%d core_id=%d, {%d %d, s %d}\n", cls_id, cid, m, n, stride_n);
        int step = (m + 15)/ 16;
        for (int32_t i = 0; i < m; i+=step) {
            printf("%d,%d/m{%d}[", cls_id, cid, i);
            for (int32_t j = 0; j < min(8, n); j++) {
                printf("%6.1f ", half2float(tensor[i * stride_n + j]));
            }
            printf("]\n");
        }
    }
}

__device__ void printTensorI8(_shared_ptr_ int8_t *tensor, int32_t m, int32_t n, int32_t stride_n) {
    int cid = core_id();
    int cls_id = cluster_id();
    if (cls_id == __CHECK_CLUSTER_ID) {
        printf("\nprintTensorInt8 cluster_id=%d core_id=%d, {%d %d, s %d}\n", cls_id, cid, m, n, stride_n);
        int step = (m + 15)/ 16;
        for (int32_t i = 0; i < m; i+=step) {
            printf("%d,%d/m{%d}[", cls_id, cid, i);
            for (int32_t j = 0; j < min(4, n); j++) {
                printf("%d ", tensor[i * stride_n + j]);
            }
            printf("... ");
            for (int32_t j = max(n - 4, 0) ; j < n; j++) {
                printf("%d ", tensor[i * stride_n + j]);
            }
            printf("]\n");
        }
    }
}

#endif

} // namespace xpu
